	inline bool IsEdgePCB(const cv::Mat& src, int x, int y, double theta)
	{
		const int n_rows = src.rows;
		const int n_cols = src.cols;
		const int len = 5;

		theta += PI / 2;
		if (theta >= 2 * PI)
			theta -= 2 * PI;

		int direction = (int)std::round(theta / (PI / 4));
		if (direction == 8)
			direction = 0;

		std::vector<unsigned char> large_vec;
		std::vector<unsigned char> small_vec;

		//printf("direction %d, x %d, y %d\n", direction, x, y);
		cv::Vec3b color_large(0, 0, 255);
		cv::Vec3b color_small(0, 255, 0);
		
		for (int i = 1; i <= len; ++i)
		{
			switch (direction)
			{
			case 0:
				if (y + i < n_rows)
				{
					small_vec.push_back(src.at<unsigned char>(y + i, x));
					//img_show.at<cv::Vec3b>(y + i, x) = color_small;
				}
				if (y - i >= 0)
				{
					large_vec.push_back(src.at<unsigned char>(y - i, x));
					//img_show.at<cv::Vec3b>(y - i, x) = color_large;
				}
				break;
			case 1:
				if (x - i >= 0 && y + i < n_rows)
				{
					small_vec.push_back(src.at<unsigned char>(y + i, x - i));
					//img_show.at<cv::Vec3b>(y + i, x - i) = color_small;
				}
				if (x + i < n_cols && y - i >= 0)
				{
					large_vec.push_back(src.at<unsigned char>(y - i, x + i));
					//img_show.at<cv::Vec3b>(y - i, x + i) = color_large;
				}
				break;
			case 2:
				if (x - i >= 0)
				{
					small_vec.push_back(src.at<unsigned char>(y, x - i));
					//img_show.at<cv::Vec3b>(y, x - i) = color_small;
				}
				if (x + i < n_cols)
				{
					large_vec.push_back(src.at<unsigned char>(y, x + i));
					//img_show.at<cv::Vec3b>(y, x + i) = color_large;
				}
				break;
			case 3:
				if (x - i >= 0 && y - i >= 0)
				{
					small_vec.push_back(src.at<unsigned char>(y - i, x - i));
					//img_show.at<cv::Vec3b>(y - i, x - i) = color_small;
				}
				if (x + i < n_cols && y + i < n_rows)
				{
					large_vec.push_back(src.at<unsigned char>(y + i, x + i));
					//img_show.at<cv::Vec3b>(y + i, x + i) = color_large;
				}
				break;
			case 4:
				if (y - i >= 0)
				{
					small_vec.push_back(src.at<unsigned char>(y - i, x));
					//img_show.at<cv::Vec3b>(y - i, x) = color_small;
				}
				if (y + i < n_rows)
				{
					large_vec.push_back(src.at<unsigned char>(y + i, x));
					//img_show.at<cv::Vec3b>(y + i, x) = color_large;
				}
				break;
			case 5:
				if (x + i < n_cols && y - i >= 0)
				{
					small_vec.push_back(src.at<unsigned char>(y - i, x + i));
					//img_show.at<cv::Vec3b>(y - i, x + i) = color_small;
				}
				if (x - i >= 0 && y + i < n_rows)
				{
					large_vec.push_back(src.at<unsigned char>(y + i, x - i));
					//img_show.at<cv::Vec3b>(y + i, x - i) = color_large;
				}
				break;
			case 6:
				if (x + i < n_cols)
				{
					small_vec.push_back(src.at<unsigned char>(y, x + i));
					//img_show.at<cv::Vec3b>(y, x + i) = color_small;
				}
				if (x - i >= 0)
				{
					large_vec.push_back(src.at<unsigned char>(y, x - i));
					//img_show.at<cv::Vec3b>(y, x - i) = color_large;
				}
				break;
			case 7:
				if (x + i < n_cols && y + i < n_rows)
				{
					small_vec.push_back(src.at<unsigned char>(y + i, x + i));
					//img_show.at<cv::Vec3b>(y + i, x + i) = color_small;
				}
				if (x - i >= 0 && y - i >= 0)
				{
					large_vec.push_back(src.at<unsigned char>(y - i, x - i));
					//img_show.at<cv::Vec3b>(y - i, x - i) = color_large;
				}
				break;
			default:
				;//do nothing
			}
		}


		std::vector<unsigned char> both_vec;
		for (int i = 0; i < (int)large_vec.size(); ++i)
			both_vec.push_back(large_vec[i]);
		for (int i = 0; i < (int)small_vec.size(); ++i)
			both_vec.push_back(small_vec[i]);
		std::sort(both_vec.begin(), both_vec.end());

		unsigned char median = both_vec[(large_vec.size() + small_vec.size()) / 2];
		
		int average_large = 0;
		int average_small = 0;
		for (int i = 0; i < (int)large_vec.size(); ++i)
			average_large += (int)large_vec[i];
		average_large /= (int)large_vec.size();
		for (int i = 0; i < (int)small_vec.size(); ++i)
			average_small +=(int) small_vec[i];
		average_small /= (int)small_vec.size();

		//for (int i = 0; i < (int)large_vec.size(); ++i)
		//	std::cout << (int)large_vec[i] << "\t";
		//std::cout << std::endl;
		//for (int i = 0; i < (int)small_vec.size(); ++i)
		//	std::cout << (int)small_vec[i] << "\t";
		//std::cout << std::endl;
		//std::cout << "median : " << (int)median << std::endl;
		//system("pause");

		/*printf("large %d, small %d\n", average_large, average_small);
		return true;*/

		if (average_large - average_small > 50)
		{
#if 0
			for (int i = 1; i <= len; ++i)
			{
				switch (direction)
				{
				case 0:
					if (y + i < n_rows)
					{
						small_vec.push_back(src.at<unsigned char>(y + i, x));
						img_show.at<cv::Vec3b>(y + i, x) = color_small;
					}
					if (y - i >= 0)
					{
						large_vec.push_back(src.at<unsigned char>(y - i, x));
						img_show.at<cv::Vec3b>(y - i, x) = color_large;
					}
					break;
				case 1:
					if (x - i >= 0 && y + i < n_rows)
					{
						small_vec.push_back(src.at<unsigned char>(y + i, x - i));
						img_show.at<cv::Vec3b>(y + i, x - i) = color_small;
					}
					if (x + i < n_cols && y - i >= 0)
					{
						large_vec.push_back(src.at<unsigned char>(y - i, x + i));
						img_show.at<cv::Vec3b>(y - i, x + i) = color_large;
					}
					break;
				case 2:
					if (x - i >= 0)
					{
						small_vec.push_back(src.at<unsigned char>(y, x - i));
						img_show.at<cv::Vec3b>(y, x - i) = color_small;
					}
					if (x + i < n_cols)
					{
						large_vec.push_back(src.at<unsigned char>(y, x + i));
						img_show.at<cv::Vec3b>(y, x + i) = color_large;
					}
					break;
				case 3:
					if (x - i >= 0 && y - i >= 0)
					{
						small_vec.push_back(src.at<unsigned char>(y - i, x - i));
						img_show.at<cv::Vec3b>(y - i, x - i) = color_small;
					}
					if (x + i < n_cols && y + i < n_rows)
					{
						large_vec.push_back(src.at<unsigned char>(y + i, x + i));
						img_show.at<cv::Vec3b>(y + i, x + i) = color_large;
					}
					break;
				case 4:
					if (y - i >= 0)
					{
						small_vec.push_back(src.at<unsigned char>(y - i, x));
						img_show.at<cv::Vec3b>(y - i, x) = color_small;
					}
					if (y + i < n_rows)
					{
						large_vec.push_back(src.at<unsigned char>(y + i, x));
						img_show.at<cv::Vec3b>(y + i, x) = color_large;
					}
					break;
				case 5:
					if (x + i < n_cols && y - i >= 0)
					{
						small_vec.push_back(src.at<unsigned char>(y - i, x + i));
						img_show.at<cv::Vec3b>(y - i, x + i) = color_small;
					}
					if (x - i >= 0 && y + i < n_rows)
					{
						large_vec.push_back(src.at<unsigned char>(y + i, x - i));
						img_show.at<cv::Vec3b>(y + i, x - i) = color_large;
					}
					break;
				case 6:
					if (x + i < n_cols)
					{
						small_vec.push_back(src.at<unsigned char>(y, x + i));
						img_show.at<cv::Vec3b>(y, x + i) = color_small;
					}
					if (x - i >= 0)
					{
						large_vec.push_back(src.at<unsigned char>(y, x - i));
						img_show.at<cv::Vec3b>(y, x - i) = color_large;
					}
					break;
				case 7:
					if (x + i < n_cols && y + i < n_rows)
					{
						small_vec.push_back(src.at<unsigned char>(y + i, x + i));
						img_show.at<cv::Vec3b>(y + i, x + i) = color_small;
					}
					if (x - i >= 0 && y - i >= 0)
					{
						large_vec.push_back(src.at<unsigned char>(y - i, x - i));
						img_show.at<cv::Vec3b>(y - i, x - i) = color_large;
					}
					break;
				default:
					;//do nothing
				}
			}
#endif
			return true;
		}
			
		else
			return false;
	}
	
	
	
	
	
#if 0
void Show(float* img, int n_rows, int n_cols, std::string win_name, int ms)
{
	cv::Mat mat(n_rows, n_cols, CV_32FC1);
	for (int x = 0; x < n_cols; ++x)
	{
		for (int y = 0; y < n_rows; ++y)
		{
			mat.at<float>(y, x) = img[y*n_cols + x];
		}
	}
	mat.convertTo(mat, CV_8UC1);
	cv::imshow(win_name.c_str(), mat);
	cv::waitKey(ms);
}

void BlurModelDetector::Detect(
	const cv::Mat _src,
	std::vector<cv::Point2f>& supixel_edge_points,
	std::vector<float>& thetas)
{
	
	const int n_rows = _src.rows;
	const int n_cols = _src.cols;
	//remenber to delete
	unsigned char* src = new  unsigned char[n_rows * n_cols];
	short* img = new short[n_rows * n_cols];
	short* gradient_x = new short[n_rows * n_cols];
	short* gradient_y = new short[n_rows * n_cols];
	short* gradient = new short[n_rows * n_cols];

	memcpy(src, _src.data, n_rows*n_cols*sizeof(unsigned char));
	
	for (int i = 0, n_pixels = n_rows*n_cols; i < n_pixels; ++i)
		img[i] = src[i];

	const int a = 2;

	//-- step 1 : calculate the first derivatives Ex, Ey, M(x,y)--------------------
	clock_t start_time = clock();
	GetGradient(img, n_rows, n_cols, gradient_x, gradient_y);
	//printf("time : %d\n", clock() - start_time);

	//Show(img, n_rows, n_cols, "img", 0);
	//Show(gradient_x, n_rows, n_cols, "img", 0);
	//Show(gradient_y, n_rows, n_cols, "img", 0);
	//Show(gradient, n_rows, n_cols, "img", 0);
	
	//system("pause");

	//-- step 2 : canny--------------------------------------------------------
	cv::Mat canny_result;
	cv::Canny(_src, canny_result, 120, 100);
	//cv::imshow("canny_result", canny_result);
	//cv::waitKey(0);

	//-- step 3 : calculate the sx, sy, rho------------------------------------
	//std::vector<cv::Point2f> supixel_edge_points;
	//std::vector<float> thetas;

	for (int x = a, x_end = n_cols - a; x < x_end; ++x)
	{
		for (int y = a, y_end = n_rows - a; y < y_end; ++y)
		{
			if (canny_result.at<unsigned char>(y, x) == 0)
				continue;
			double bl, br, M0, M1, M2;
			double sx, sy, rho;
			std::vector<double> f;
			//-- calculate sx-------------------------------
			bl = gradient_x[y*n_cols + x - a]; // bl=f(-a);
			br = gradient_x[y*n_cols + x + a]; // br=f(+a);
			f.clear();
			for (int i = -a; i <= a; ++i)
				f.push_back(gradient_x[y*n_cols + x + i]);
			M0 = cal_M(f, 0);
			M1 = cal_M(f, 1);
			M2 = cal_M(f, 2);
			sx = a*(bl + br)*M1 - M0*M1 + (bl - br)*M2;
			sx /= a*(bl + br)*M0 - M0*M0 + (bl - br)*M1;

			//-- calculate sy----------------------------------
			bl = gradient_x[(y - a)*n_cols + x]; // bl=f(-a);
			br = gradient_x[(y + a)*n_cols + x]; // br=f(+a);
			f.clear();
			for (int i = -a; i <= a; ++i)
				f.push_back(gradient_x[(y + i)*n_cols + x]);
			M0 = cal_M(f, 0);
			M1 = cal_M(f, 1);
			M2 = cal_M(f, 2);
			sy = a*(bl + br)*M1 - M0*M1 + (bl - br)*M2;
			sy /= a*(bl + br)*M0 - M0*M0 + (bl - br)*M1;

			//-- calculate rho---------------------------
			rho = std::abs(sx*sy) / std::sqrt(sx*sx + sy*sy);


			//-- calculate the subpixel location
			//double dx = rho*std::cos(theta);
			//double dy = rho*std::sin(theta);
			double gx = gradient_x[y*n_cols + x];
			double gy = gradient_x[y*n_cols + x];
			double theta = std::atan(gy / gx);
			const double PI = 3.14159265354;
			double x_new = (double)x;
			double y_new = (double)y;
			if (theta >= -PI / 4 && theta <= PI / 4)
			{
				if (std::abs(sx)>2.0)
					sx = 0;
				x_new += sx;
			}
			else
			{
				if (std::abs(sy)>2.0)
					sy = 0;
				y_new += sy;
			}

			//const double PI = 3.1415926;
			if (gx < 0 && gy < 0)
				theta += PI;
			if (gx<0 && gy>0)
				theta += PI;

			supixel_edge_points.push_back(cv::Point2f(x_new, y_new));
			thetas.push_back(theta);

		}
	}//main loop
}


void BlurModelDetector::GetGradient(
	const short* img, int n_rows, int n_cols,
	short* gradient_x, short* gradient_y)
{
	//sobel gradient
	//kernel_x
	// -1 0 1
	// -2 0 2
	// -1 0 1
	//kernel_y
	// -1 -2 -1
	//  0  0  0
	//  1  2  1
	const int x_min = 1;
	const int x_max = n_cols - 1;
	const int y_min = 1;
	const int y_max = n_rows - 1;

	for (int x = x_min; x < x_max; ++x)
	{
		for (int y = y_min; y < y_max; ++y)
		{
			int i = y*n_cols + x;
			
			short x_m_1_y_m_1 = img[i - n_cols - 1];
			short x_m_0_y_m_1 = img[i - n_cols];
			short x_p_1_y_m_1 = img[i - n_cols + 1];
			
			short x_m_1_y_m_0 = img[i - 1];
			short x_p_1_y_m_0 = img[i + 1];
			
			short x_m_1_y_p_1 = img[i + n_cols - 1];
			short x_m_0_y_p_1 = img[i + n_cols];
			short x_p_1_y_p_1 = img[i + n_cols + 1];


			gradient_x[i] = \
				- x_m_1_y_m_1 \
				- x_m_1_y_m_0 << 1 \
				- x_m_1_y_p_1 \
				+ x_p_1_y_m_1 \
				+ x_p_1_y_m_0 << 1 \
				+ x_p_1_y_p_1;
			gradient_y[i] = \
				- x_m_1_y_m_1 \
				- x_m_0_y_m_1 << 1 \
				- x_p_1_y_m_1 \
				+ x_m_1_y_p_1 \
				+ x_m_0_y_p_1 << 1  \
				+ x_p_1_y_p_1;
		}
	}
}
#endif